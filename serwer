import { aStar } from './nav03.js';
import {
    Vector, Heap, ManhattanDistance,
    duwsenDirectionVectors, FaceToIndex, 
    neswudDirectionVectors
} from './utils.js';

const WebSocket = require('ws');
const fs = require('fs');
const path = require('path');

const server = new WebSocket.Server({ port: 8080 });
let TurtleObjects = {};
let LiveTurtles = {};
const WorldMap = {};
let PCs = [];
const computercraftDirectory = './computercraft';

// ---- load WorldMap from disk ----
if (fs.existsSync('WorldMap.json')) {
    try {
        const data = fs.readFileSync('WorldMap.json', 'utf8');
        Object.assign(WorldMap, JSON.parse(data));
    } catch (error) {
        console.error('Error reading WorldMap.json:', error);
    }
}

// ---- safe socket send wrapper ----
function safeSend(s, payload) {
    try {
        if (s && s.readyState === WebSocket.OPEN) {
            s.send(JSON.stringify(payload));
        }
    } catch (err) {
        console.error('socket send error:', err);
    }
}

// ---- debounced WorldMap saving ----
let saveTimer = null;
function saveWorldMap() {
    if (saveTimer) clearTimeout(saveTimer);
    saveTimer = setTimeout(() => {
        fs.promises.writeFile('WorldMap.json', JSON.stringify(WorldMap, null, 2))
            .catch(err => console.error('Failed to save WorldMap:', err));
        saveTimer = null;
    }, 200); // batch updates within 200ms
}

function JustNumber(parsedName) {
  return /^[0-9]+$/.test(parsedName);
}

function updateTurtleObjects(directory) {
    if (!directory) directory = computercraftDirectory;
    let FoundTurtleObjects = {};

    const files = fs.readdirSync(directory, { withFileTypes: true });

    files.forEach(file => {
        const fullPath = path.join(directory, file.name);
        const parsedName = path.parse(file.name).name;

        if (file.isDirectory()) {
            if (!JustNumber(parsedName)) {
                try {
                    const child = updateTurtleObjects(fullPath);
                    Object.assign(FoundTurtleObjects, child);
                } catch (err) {
                    console.error(`Error scanning directory ${fullPath}:`, err);
                }
            }
        } else if (file.name.startsWith("TurtleLog")) {
            try {
                const fileContent = fs.readFileSync(fullPath, "utf8");
                const parsed = JSON.parse(fileContent);

                if (Array.isArray(parsed)) {
                    parsed.forEach(turtle => {
                        if (turtle && turtle.id !== undefined) {
                            FoundTurtleObjects[turtle.id] = turtle;
                        }
                    });
                } else if (parsed && typeof parsed === "object") {
                    Object.assign(FoundTurtleObjects, parsed);
                }
            } catch (err) {
                console.error(`Failed to parse ${fullPath}:`, err.message);
            }
        }
    });

    // cleanup old turtles
    Object.values(TurtleObjects).forEach(turtle => {
        if (!turtle || !turtle.position) return;
        const posKey = turtle.position.toString();
        const turtlesAtPos = WorldMap[posKey]?.turtles;
        if (turtlesAtPos) {
            const turtleKey = turtlesAtPos[turtle.id] || null;
            if (turtleKey && !turtleKey.unixLeaveTime && !turtleKey.unixArriveTime) {
                delete turtlesAtPos[turtle.id];
            }
        }
    });

    TurtleObjects = FoundTurtleObjects;

    // reset idle turtles
    Object.values(TurtleObjects).forEach(turtle => {
        if (!turtle || !turtle.position) return;
        const turtlesAtPos = WorldMap[turtle.position.toString()]?.turtles;
        if (turtlesAtPos && turtlesAtPos[turtle.id] && turtle.busy === false) {
            if ('unixArriveTime' in turtlesAtPos[turtle.id]) turtlesAtPos[turtle.id].unixArriveTime = null;
            if ('unixLeaveTime' in turtlesAtPos[turtle.id]) turtlesAtPos[turtle.id].unixLeaveTime = null;

            Object.entries(turtlesAtPos).forEach(([interruptedID, interruptedTurtle]) => {
                if (interruptedID !== String(turtle.id) && interruptedTurtle?.unixArriveTime >= Date.now()) {
                    safeSend(LiveTurtles[interruptedID], { type: 'obstacle on your way' });
                }
            });
        }
    });

    return FoundTurtleObjects;
}

// ---- websocket server ----
server.on('connection', socket => {
    console.log('New connection established');
    safeSend(socket, 'PC?');

    socket.on('message', rawData => {
        let message;
        try {
            const dataStr = typeof rawData === 'string' ? rawData : rawData.toString('utf8');
            message = JSON.parse(dataStr);
        } catch (err) {
            console.error('Failed to parse incoming message:', err);
            return;
        }

        if (message.type === 'PassThrough') {
            const returnMessage = { ...message, type: message.newHeader || 'PassThrough' };
            delete returnMessage.newHeader;

            const receiver = message.receiver;
            if (LiveTurtles[receiver]) {
                safeSend(LiveTurtles[receiver], returnMessage);
            } else {
                console.log(`Turtle ${receiver} has no active socket connection.`);
            }
        }

        if (message.type === 'MapUpdate') {
            const detected = message.payload;
            let change = false;
            
            for (const vectorKey in detected) {
                const inspectVariables = detected[vectorKey];

                if (inspectVariables.blocked && !WorldMap[vectorKey]) {
                    WorldMap[vectorKey] = inspectVariables.data;
                    WorldMap[vectorKey].blocked = true;
                    change = true;
                    
                    Object.entries(WorldMap[vectorKey]["turtles"]).forEach(([interruptedID, interruptedTurtle]) => {
                        if (interruptedTurtle.unixArriveTime >= Date.now()) {
                            safeSend(LiveTurtles[interruptedID], { type: 'obstacle on your way' });
                        }
                    });
                } else if (!inspectVariables.blocked && WorldMap[vectorKey]) {
                    delete WorldMap[vectorKey];
                    change = true;
                }
            }

            if (change) saveWorldMap();
        }

        if (message.type === 'MapRequest') {
            safeSend(socket, { type: 'MapSupply', payload: WorldMap });
        }

        if (message.type === 'PCConfirm') {
            if (!PCs.includes(socket)) {
                console.log('PC connected');
                PCs.push(socket);
            }
        }

        if (message.type === 'TurtleBorn') {
            const turtleID = message.payload.TurtleObject.id;
            if (LiveTurtles[turtleID]) {
                console.warn(`Turtle ${turtleID} is already registered, replacing socket`);
            }
            LiveTurtles[turtleID] = socket;
            console.log(`Turtle ${turtleID} registered at ${message.payload.TurtleObject.position}`);
        }

        if (message.type === 'Journey') {
            const calculationStart = Date.now();
            const destinations = message.payload.destinations;
            const TurtleObject = message.payload.TurtleObject;
            const turtleID = TurtleObject.id;
            const networkDelay = Date.now() - message.payload.sendTime || 0;

            const journeyPath = aStar(
                TurtleObject.position,
                destinations,
                TurtleObject.fuel,
                WorldMap, 
            );

            let returnMessage;
            if (journeyPath) {
                let delay = Date.now() - calculationStart + networkDelay;

                for (const step of journeyPath) {
                    if (step.waitTime > 0) {
                        let diff = step.waitTime - delay;
                        if (diff > 0) {
                            step.waitTime -= delay;
                            delay = 0;
                        } else {
                            step.waitTime = 0;
                            delay = Math.abs(diff);
                        }
                    }

                    if (step.unixArriveTime != null) step.unixArriveTime += delay;
                    if (step.unixLeaveTime != null) step.unixLeaveTime += delay;

                    if (!WorldMap[step.vector]) WorldMap[step.vector] = { turtles: {} };
                    if (!WorldMap[step.vector].turtles) WorldMap[step.vector].turtles = {};

                    WorldMap[step.vector].turtles[turtleID] = {
                        ...(WorldMap[step.vector].turtles[turtleID] || {}),
                        ...(step.turtles?.[turtleID] || {})
                    };
                }

                Object.entries(journeyPath[journeyPath.length - 1]["turtles"]).forEach(([interruptedID, interruptedTurtle]) => {
                    if (interruptedTurtle.unixArriveTime >= Date.now()) {
                        safeSend(LiveTurtles[interruptedID], { type: 'obstacle on your way' });
                    }
                });

                saveWorldMap();

                returnMessage = { type: 'NewPath', payload: journeyPath };
            } else {
                returnMessage = { type: 'NewPath', payload: 'no path found' };
            }

            safeSend(socket, returnMessage);
        }

        if (message.type === 'Delay Adjustment') {
            const delay = message.payload.delay + Date.now() - message.payload.sendTime;
            const journeyStepIndex = message.payload.TurtleObject.journeyStepIndex - 1;
            const turtleID = message.payload.TurtleObject.id;
            const journeyPath = message.payload.journeyPath;

            const firstStepVector = journeyPath[journeyStepIndex].vector;
            const firstStepTurtle = WorldMap[firstStepVector]?.turtles?.[turtleID];
            if (firstStepTurtle && firstStepTurtle.unixLeaveTime != null) {
                firstStepTurtle.unixLeaveTime += delay;
            }

            for (let i = journeyStepIndex + 1; i < journeyPath.length; i++) {
                const stepVector = journeyPath[i].vector;
                const t = WorldMap[stepVector]?.turtles?.[turtleID];
                if (!t) continue;
                if (t.unixArriveTime != null) t.unixArriveTime += delay;
                if (t.unixLeaveTime != null) t.unixLeaveTime += delay;
            }
        }

        if (message.type === 'Journeys End') {
            const journeyPath = message.payload.journeyPath;
            const turtleID = message.payload.turtleID;

            for (const step of journeyPath) {
                const key = step.vector;
                if (!WorldMap[key] || !WorldMap[key].turtles) continue;

                delete WorldMap[key].turtles[turtleID];
                if (Object.keys(WorldMap[key].turtles).length === 0) {
                    delete WorldMap[key];
                }
            }

            updateTurtleObjects();
            saveWorldMap();
        }

        if (message.type === 'TurtleScan') {
            updateTurtleObjects();
            safeSend(socket, { type: 'TurtleScanResult', payload: TurtleObjects });
        }

        if (message.type === 'blockData') {
            const blockData = {};
            for (const vector of message.payload) {
                blockData[vector.toString()] = WorldMap[vector.toString()] || null;
            }
            safeSend(socket, { type: 'blockData', payload: blockData });
        }
    });
    
    socket.on('close', () => {
        console.log('Socket closed');

        // remove from LiveTurtles
        let disconnectedID = null;
        for (const [id, liveSocket] of Object.entries(LiveTurtles)) {
            if (liveSocket === socket) {
                disconnectedID = id;
                delete LiveTurtles[id];
            }
        }

        // remove from PCs
        PCs = PCs.filter(pc => pc !== socket);

        const returnMessage = {
            type: 'TurtleDisconnect',
            payload: disconnectedID ? `A turtle with the ID ${disconnectedID} disconnected` : 'A turtle disconnected'
        };

        for (const pc of PCs) {
            safeSend(pc, returnMessage);
        }
    });
});
