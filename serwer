// server.js  (single-file, updated and fixed)
const { aStar } = require('./nav03.js');
const {
    Vector, Heap, ManhattanDistance,
    duwsenDirectionVectors, FaceToIndex,
    neswudDirectionVectors
} = require('./utils.js');

const WebSocket = require('ws');
const fs = require('fs');
const path = require('path');

const server = new WebSocket.Server({ port: 8080 });
let TurtleObjects = {};
const WorldMap = {};
let PCs = [];
const computercraftDirectory = './computercraft';

// Load persistent world map if present
if (fs.existsSync('WorldMap.json')) {
    try {
        const data = fs.readFileSync('WorldMap.json', 'utf8');
        Object.assign(WorldMap, JSON.parse(data));
    } catch (error) {
        console.error('Error reading WorldMap.json:', error);
    }
}

// Save WorldMap asynchronously (non-blocking) with simple error logging
function saveWorldMap() {
    fs.writeFile('WorldMap.json', JSON.stringify(WorldMap, null, 2), (err) => {
        if (err) {
            console.error('Failed to write WorldMap.json:', err);
        }
    });
}

function JustNumber(parsedName) {
    return /^[0-9]+$/.test(parsedName);
}

function findTurtleLogs(directory, IDs) {
    let FoundTurtleObjects = {};

    const files = fs.readdirSync(directory, { withFileTypes: true });

    files.forEach(file => {
        const fullPath = path.join(directory, file.name);
        const parsedName = path.parse(file.name).name;

        if (file.isDirectory()) {
            // if IDs provided, only descend into matching directories OR non-numeric names
            if (!IDs || IDs.includes(parsedName) || !JustNumber(parsedName)) {
                try {
                    Object.assign(FoundTurtleObjects, findTurtleLogs(fullPath, IDs));
                } catch (e) {
                    console.error(`Error reading directory ${fullPath}:`, e);
                }
            }
        } else if (file.name.startsWith('TurtleLog')) {
            try {
                const fileContent = fs.readFileSync(fullPath, 'utf8');
                Object.assign(FoundTurtleObjects, JSON.parse(fileContent));
            } catch (err) {
                console.error(`Failed to parse ${fullPath}:`, err.message);
            }
        }
    });

    TurtleObjects = FoundTurtleObjects;
    return FoundTurtleObjects;
}

// Safe send helper: check readyState and catch send errors
function safeSend(socket, obj) {
    if (!socket) return false;
    try {
        if (socket.readyState === WebSocket.OPEN) {
            socket.send(JSON.stringify(obj));
            return true;
        } else {
            // socket not open
            return false;
        }
    } catch (err) {
        console.error('safeSend error:', err);
        return false;
    }
}

// Avoid duplicate PC entries
function addPC(socket) {
    if (!PCs.includes(socket)) {
        PCs.push(socket);
    }
}

function removePC(socket) {
    const idx = PCs.indexOf(socket);
    if (idx !== -1) {
        PCs.splice(idx, 1);
    }
}

server.on('connection', socket => {
    console.log('New connection established');
    // ask for identity
    safeSend(socket, 'PC?');

    socket.on('message', data => {
        let message;
        try {
            message = JSON.parse(data);
        } catch (err) {
            console.error('Invalid JSON received:', data);
            return;
        }

        // --- PassThrough (forward message to a turtle) ---
        if (message.type === 'PassThrough') {
            const receiverID = message.receiver;
            const targetTurtle = TurtleObjects[receiverID];

            if (targetTurtle && targetTurtle.socket && targetTurtle.socket.readyState === WebSocket.OPEN) {
                const returnMessage = {
                    ...message,
                    type: message.newHeader || 'PassThrough',
                };
                delete returnMessage.newHeader;

                safeSend(targetTurtle.socket, returnMessage);
            } else {
                console.warn(`PassThrough failed: Turtle '${receiverID}' not found or disconnected.`);
            }
            return;
        }

        // --- MapUpdate (merge updates into WorldMap) ---
        if (message.type === 'MapUpdate') {
            const detected = message.payload;
            let change = false;

            for (const vectorKey in detected) {
                const inspectVariables = detected[vectorKey];

                if (inspectVariables.blocked) {
                    // merge new data with existing (preserve metadata)
                    WorldMap[vectorKey] = {
                        ...(WorldMap[vectorKey] || {}),
                        ...(inspectVariables.data || {}),
                        blocked: true
                    };
                    change = true;
                } else {
                    // if it is unblocked and there is existing data, remove it
                    if (WorldMap[vectorKey]) {
                        delete WorldMap[vectorKey];
                        change = true;
                    }
                }
            }

            if (change) saveWorldMap();
            return;
        }

        // --- MapRequest ---
        if (message.type === 'MapRequest') {
            safeSend(socket, {
                type: 'MapSupply',
                payload: WorldMap
            });
            return;
        }

        // --- PC registration ---
        if (message.type === 'PCConfirm') {
            addPC(socket);
            return;
        }

        // --- TurtleBorn (register turtle) ---
        if (message.type === 'TurtleBorn') {
            const TurtleObject = message.payload.TurtleObject;
            const turtleId = TurtleObject.id || TurtleObject.turtleID;
            if (!turtleId) {
                console.warn('TurtleBorn without id/turtleID', TurtleObject);
            } else {
                TurtleObjects[turtleId] = { socket, ...message.payload };
                console.log(`Turtle ${turtleId} registered at ${JSON.stringify(TurtleObject.position)}`);
            }
            return;
        }

        // --- Journey (pathfinding request) ---
        if (message.type === 'Journey') {
            const calculationStart = Date.now();
            const destinations = message.payload.destinations;
            const TurtleObject = message.payload.TurtleObject || {};
            const turtleID = TurtleObject.id || TurtleObject.turtleID;
            const doAtTheEnd = message.payload.doAtTheEnd || 'go';
            const networkDelay = message.payload.sendTime ? (Date.now() - message.payload.sendTime) : 0;

            const journeyPath = aStar(
                TurtleObject.position,
                destinations,
                TurtleObject.fuel,
                WorldMap,
            );

            let returnMessage;
            if (journeyPath) {
                let delay = Date.now() - calculationStart + networkDelay;

                for (let i = 0; i < journeyPath.length; i++) {
                    const step = journeyPath[i];

                    // --- sync delay handling ---
                    if (step.syncDelay > 0) {
                        let diff = step.syncDelay - delay;
                        if (diff > 0) {
                            step.syncDelay -= delay;
                            delay = 0;
                        } else {
                            step.syncDelay = 0;
                            delay = Math.abs(diff);
                        }
                    }

                    if (step.unixArriveTime != null) step.unixArriveTime += delay;
                    if (step.unixLeaveTime != null) step.unixLeaveTime += delay;

                    // --- skip final step if needed ---
                    if (i === journeyPath.length - 1 && !doAtTheEnd.includes('go')) {
                        break;
                    }

                    // --- ensure WorldMap entry exists and merge metadata ---
                    if (!WorldMap[step.vector]) {
                        WorldMap[step.vector] = { turtles: {} };
                    } else if (!WorldMap[step.vector].turtles) {
                        WorldMap[step.vector].turtles = {};
                    }

                    // --- register this turtle in object form (merge existing turtle metadata) ---
                    const existing = WorldMap[step.vector].turtles[turtleID] || {};
                    const stepTurtleData = (step.turtles && step.turtles[turtleID]) ? step.turtles[turtleID] : {};
                    WorldMap[step.vector].turtles[turtleID] = {
                        ...existing,
                        ...stepTurtleData
                    };
                }

                saveWorldMap();

                // Filter to include only steps relevant to this turtle (or steps without turtle-specific data if that's what you want)
                // I assume you want steps that include data for this turtle (previously code filtered opposite).
                const filteredJourney = journeyPath.filter(step =>
                    !step.turtles || Object.keys(step.turtles).length === 0 || (turtleID && step.turtles?.[turtleID])
                );

                returnMessage = {
                    type: 'NewPath',
                    payload: {
                        journeyPath: filteredJourney,
                    }
                };
            } else {
                returnMessage = {
                    type: 'NewPath',
                    payload: 'no path found'
                };
            }

            safeSend(socket, returnMessage);
            return;
        }

        // --- Delay Adjustment ---
        if (message.type === 'Delay Adjustment') {
            // Calculate delay using sendTime if present
            const delay = (typeof message.payload.delay === 'number' ? message.payload.delay : 0) +
                (message.payload.sendTime ? (Date.now() - message.payload.sendTime) : 0);

            const journeyStepIndex = (message.payload.TurtleObject && typeof message.payload.TurtleObject.journeyStepIndex === 'number')
                ? message.payload.TurtleObject.journeyStepIndex - 1
                : 0;

            const turtleID = (message.payload.TurtleObject && (message.payload.TurtleObject.id || message.payload.TurtleObject.turtleID))
                || message.payload.turtleID;

            const journeyPath = message.payload.journeyPath || [];

            // adjust the first step
            if (journeyPath[journeyStepIndex]) {
                const firstStepVector = journeyPath[journeyStepIndex].vector;
                const firstStepTurtle = WorldMap[firstStepVector]?.turtles?.[turtleID];

                if (firstStepTurtle && firstStepTurtle.unixLeaveTime != null) {
                    firstStepTurtle.unixLeaveTime += delay;
                }
            }

            // adjust remaining steps in WorldMap for that turtle
            for (let i = journeyStepIndex + 1; i < journeyPath.length; i++) {
                const stepVector = journeyPath[i].vector;
                const t = WorldMap[stepVector]?.turtles?.[turtleID];

                if (!t) continue;

                if (t.unixArriveTime != null) t.unixArriveTime += delay;
                if (t.unixLeaveTime != null) t.unixLeaveTime += delay;
            }

            saveWorldMap();
            return;
        }

        // --- Journeys End (cleanup turtle presence on steps) ---
        if (message.type === 'Journeys End') {
            const journeyPath = message.payload.journeyPath || [];
            const turtleID = message.payload.turtleID;

            for (const step of journeyPath) {
                const key = step.vector;

                if (!WorldMap[key] || !WorldMap[key].turtles) {
                    continue;
                }

                // remove this turtle
                delete WorldMap[key].turtles[turtleID];

                // cleanup if no turtles left
                if (Object.keys(WorldMap[key].turtles).length === 0) {
                    delete WorldMap[key].turtles;
                }
            }

            // notify other turtles at last position
            const returnMessage = { type: 'obstacle on your way' };
            const lastStep = journeyPath[journeyPath.length - 1];
            if (lastStep) {
                const turtlesAtEnd = WorldMap[lastStep.vector]?.turtles || {};

                for (const otherTurtleID in turtlesAtEnd) {
                    if (TurtleObjects[otherTurtleID] && TurtleObjects[otherTurtleID].socket) {
                        safeSend(TurtleObjects[otherTurtleID].socket, returnMessage);
                    }
                }
            }

            saveWorldMap();
            return;
        }

        // --- TurtleScan (search computercraft dir for TurtleLog files) ---
        if (message.type === 'TurtleScan') {
            let FoundTurtleObjects;
            if (message.payload) {
                const { IDs } = message.payload;
                FoundTurtleObjects = findTurtleLogs(computercraftDirectory, IDs);
            } else {
                FoundTurtleObjects = findTurtleLogs(computercraftDirectory);
            }

            const returnMessage = {
                type: 'TurtleScanResult',
                payload: FoundTurtleObjects
            };

            safeSend(socket, returnMessage);
            return;
        }

        // --- blockData (client requests meta for specific vectors) ---
        if (message.type === 'blockData') {
            const blockData = {};
            for (const vector of message.payload) {
                blockData[vector] = WorldMap[vector] || null;
            }

            const returnMessage = {
                type: 'blockData',
                payload: blockData
            };

            safeSend(socket, returnMessage);
            return;
        }

        // Unknown message types fall through quietly (or log)
        console.warn('Unhandled message type:', message.type);
    });

    socket.on('close', () => {
        // If it was a PC, remove it
        if (PCs.includes(socket)) {
            removePC(socket);
            console.log('A PC disconnected');
            return;
        }

        // If it was a turtle, remove from registry and notify PCs
        const turtleID = Object.keys(TurtleObjects).find(id => TurtleObjects[id].socket === socket);
        if (turtleID) {
            delete TurtleObjects[turtleID];
            console.log(`Turtle ${turtleID} disconnected`);

            const returnMessage = {
                type: 'TurtleDisconnect',
                payload: turtleID
            };

            for (const pc of PCs) {
                safeSend(pc, returnMessage);
            }
        } else {
            // Unknown socket closed
            console.log('Unknown connection closed');
        }
    });

    socket.on('error', (err) => {
        console.error('Socket error:', err);
    });
});

console.log('WebSocket server listening on port 8080');