import { aStar } from './nav03.js';
import {
    Vector, Heap, ManhattanDistance,
    duwsenDirectionVectors, FaceToIndex, 
    neswudDirectionVectors
} from './utils.js';

const WebSocket = require('ws');
const fs = require('fs')
const path = require('path');

const server = new WebSocket.Server({ port: 8080 });
let TurtleObjects = {};
const WorldMap = {};
let PCs = [];
const computercraftDirectory = './computercraft';

if (fs.existsSync('WorldMap.json')) {
    try {
        const data = fs.readFileSync('WorldMap.json', 'utf8');
        Object.assign(WorldMap, JSON.parse(data));
    } catch (error) {
        console.error('Error reading WorldMap.json:', error);
    }
}

function JustNumber(parsedName) {
  return /^[0-9]+$/.test(parsedName);
}

function findTurtleLogs(directory, IDs) {
    let FoundTurtleObjects = {};

    const files = fs.readdirSync(directory, { withFileTypes: true });

    files.forEach(file => {
        const fullPath = path.join(directory, file.name);
        const parsedName = path.parse(file.name).name;

        if (file.isDirectory()) {
            if (!IDs || IDs.includes(parsedName) || !JustNumber(parsedName)) {
                Object.assign(FoundTurtleObjects, findTurtleLogs(fullPath, IDs));
            }
        } else if (file.name.startsWith('TurtleLog')) {
            try {
                const fileContent = fs.readFileSync(fullPath, 'utf8');
                Object.assign(FoundTurtleObjects, JSON.parse(fileContent));
            } catch (err) {
                console.error(`Failed to parse ${fullPath}:`, err.message);
            }    
        }    
    });

    TurtleObjects = FoundTurtleObjects;
    return FoundTurtleObjects;
}

server.on('connection', socket => {
    console.log('New connection established');
    socket.send('PC?');

    socket.on('message', data => {
        let message = JSON.parse(data);

        if (message.type === 'PassThrough') {
            for (const turtle in TurtleObjects) {
                if (TurtleObjects[turtle].id === message.receiver) {
                    const returnMessage = message
                    returnMessage.type = message.newHeader || 'PassThrough'; // Use the new header if provided, otherwise default to 'PassThrough'
                    delete returnMessage.newHeader; // Clean up the message to avoid confusion
                    socket.send(JSON.stringify(returnMessage));
                    break;
                }
            }
        }

        if (message.type === 'MapUpdate') {
            const detected = message.payload;
            let change = false;

            for (const vectorKey in detected) {
                const inspectVariables = detected[vectorKey];
            
                if (inspectVariables.blocked && !WorldMap[vectorKey]) {
                    WorldMap[vectorKey] = inspectVariables.data;
                    WorldMap[vectorKey].blocked = true; // Ensure blocked status is set
                    change = true;
                } else if (!inspectVariables.blocked && WorldMap[vectorKey]) {
                    delete WorldMap[vectorKey];
                    change = true;
                }
            }

            if (change) {
                fs.writeFileSync('WorldMap.json', JSON.stringify(WorldMap, null, 2));
            }
        }

        if (message.type === 'MapRequest') {
            message.type = 'MapSupply'
            socket.send(JSON.stringify(WorldMap));
        }

        if (message.type === 'PCConfirm') {
            PCs.push(socket);
        }

        if (message.type === 'TurtleBorn') {
            const TurtleObject = message.payload.TurtleObject;

            // Register turtle in global registry
            TurtleObjects[turtleID] = { socket, ...message.payload };
            console.log(`Turtle ${TurtleObject.id} registered at ${TurtleObject.position}`);
        }

        if (message.type === 'Journey') {
            const calculationStart = Date.now();
            const destinations = message.payload.destinations;
            const TurtleObject = message.payload.TurtleObject;
            const turtleID = TurtleObject.turtleID; // make sure turtleID is provided
            const doAtTheEnd = message.payload.doAtTheEnd || 'go';
            const networkDelay = Date.now() - message.payload.sendTime || 0;

            const journeyPath = aStar(
                TurtleObject.position,
                destinations,
                TurtleObject.fuel,
                WorldMap, 
            );

            let returnMessage;
            if (journeyPath) {
                let delay = Date.now() - calculationStart + networkDelay;

                for (let i = 0; i < journeyPath.length; i++) {
                    const step = journeyPath[i];

                    // --- sync delay handling ---
                    if (step.syncDelay > 0) {
                        let diff = step.syncDelay - delay;
                        if (diff > 0) {
                            step.syncDelay -= delay;
                            delay = 0;
                        } else {
                            step.syncDelay = 0;
                            delay = Math.abs(diff);
                        }
                    }

                    if (step['unixArriveTime'] != null) step['unixArriveTime'] += delay;
                    if (step['unixLeaveTime'] != null) step['unixLeaveTime'] += delay;   

                    // --- skip final step if needed ---
                    if (i === journeyPath.length - 1 && !doAtTheEnd.includes('go')) {
                        break;
                    }

                    // --- ensure WorldMap entry exists ---
                    if (!WorldMap[step.vector]) {
                        WorldMap[step.vector] = { turtles: {} };
                    }

                    // --- register this turtle in object form ---
                    if (!WorldMap[step.vector].turtles) {
                        WorldMap[step.vector].turtles = {};
                    }

                    WorldMap[step.vector].turtles[turtleID] = {
                        ...(WorldMap[step.vector].turtles[turtleID] || {}),
                        ...(step.turtles?.[turtleID] || {})
                    };
                }

                fs.writeFileSync('WorldMap.json', JSON.stringify(WorldMap, null, 2));

                returnMessage = {
                    type : 'NewPath',
                    payload : {
                        // filter out steps where no turtle data is relevant
                        journeyPath: journeyPath.filter(step => 
                            !step.turtles || Object.keys(step.turtles).length === 0
                        ), 
                    }
                };
            } else {
                returnMessage = {
                    type : 'NewPath',
                    payload : 'no path found'
                };
            }

            socket.send(JSON.stringify(returnMessage));
        }


        if (message.type === 'Delay Adjustment') {
            const delay = message.payload.delay + Date.now() - message.payload.sendTime;
            const journeyStepIndex = message.payload.TurtleObject.journeyStepIndex - 1;
            const turtleID = message.payload.TurtleObject.id;
            const journeyPath = message.payload.journeyPath;

            // adjust the first step
            const firstStepVector = journeyPath[journeyStepIndex].vector;
            const firstStepTurtle = WorldMap[firstStepVector]?.turtles?.[turtleID];

            if (firstStepTurtle) {
                if (firstStepTurtle.unixLeaveTime != null) {
                    firstStepTurtle.unixLeaveTime += delay;
                }
            }

            // adjust the remaining steps
            for (let i = journeyStepIndex + 1; i < journeyPath.length; i++) {
                const stepVector = journeyPath[i].vector;
                const t = WorldMap[stepVector]?.turtles?.[turtleID];

                if (!t) continue;

                if (t.unixArriveTime != null) t.unixArriveTime += delay;
                if (t.unixLeaveTime != null) t.unixLeaveTime += delay;
            }
        }

        if (message.type === 'Journeys End') {
            const journeyPath = message.payload.journeyPath;
            const turtleID = message.payload.turtleID;

            for (const step of journeyPath) {
                const key = step.vector;

                if (!WorldMap[key] || !WorldMap[key].turtles) {
                    continue; // Skip if entry doesnâ€™t exist
                }

                // remove this turtle
                delete WorldMap[key].turtles[turtleID];

                // cleanup if no turtles left
                if (Object.keys(WorldMap[key].turtles).length === 0) {
                    delete WorldMap[key].turtles;
                }
            }
            
            // notify other turtles at last position
            const returnMessage = { type: 'obstacle on your way' };
            const lastStep = journeyPath[journeyPath.length - 1];
            const turtlesAtEnd = WorldMap[lastStep.vector]?.turtles || {};

            for (const otherTurtleID in turtlesAtEnd) {
                if (TurtleObjects[otherTurtleID]) {
                    TurtleObjects[otherTurtleID].socket.send(JSON.stringify(returnMessage));
                }
            }
            
            fs.writeFileSync('WorldMap.json', JSON.stringify(WorldMap, null, 2));
        }

        if (message.type === 'TurtleScan') {
            if (message.payload) {
                const { IDs } = message.payload;
                FoundTurtleObjects = findTurtleLogs(computercraftDirectory, IDs);
            }
            else {
                FoundTurtleObjects = findTurtleLogs(computercraftDirectory);
            }
            
            const returnMessage = {
                type: 'TurtleScanResult',
                payload: FoundTurtleObjects
            };

            socket.send(JSON.stringify(returnMessage));
        }

        if (message.type === 'blockData') {
            const blockData = {}
            for (const vector of message.payload) {
                message['payload'][vector] = WorldMap[vector]
            }
            
            const returnMessage = {
                type : 'blockData',
                payload : blockData
            }

            socket.send(JSON.stringify(returnMessage));
        }
    });
    
    socket.on('close', () => {
        if (PCs.length === 0) {
            return;
        }

        console.log('Turtle disconnected');

        const returnMessage = {
            type: 'TurtleDisconnect',
            payload: Object.keys(TurtleObjects).find(id => TurtleObjects[id].socket === socket)
        };

        for (const pc of PCs) {
            pc.send(JSON.stringify(returnMessage));
        }
    });
});